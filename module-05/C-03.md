Next.js-এর আধুনিক ভার্সনে (বিশেষ করে App Router-এ) `"use server"` একটি অত্যন্ত শক্তিশালী ডিরেক্টিভ। এটি মূলত **Server Actions** তৈরি করতে ব্যবহার করা হয়।

সহজ কথায়, ক্লায়েন্ট সাইড (ব্রাউজার) থেকে সরাসরি সার্ভারের কোনো ফাংশনকে কল করার উপায় হলো `"use server"`।

### ১. `"use server"` আসলে কী?

আগে যখন আমরা ফ্রন্টএন্ড থেকে ডেটাবেসে কিছু সেভ করতে চাইতাম, তখন আমাদের একটি আলাদা API Route (যেমন: `/api/user`) তৈরি করতে হতো। কিন্তু `"use server"` ব্যবহার করলে আপনি সরাসরি একটি ফাংশন লিখবেন যা সার্ভারে চলবে, আর ব্রাউজার থেকে সেটি সাধারণ একটি ফাংশনের মতো কল করা যাবে।

এটি কোনো API endpoint না লিখেই ব্যাকএন্ডের কাজ করার সুবিধা দেয়।

---

### ২. এটি কোথায় ব্যবহার করবেন?

আপনি এটি দুইভাবে ব্যবহার করতে পারেন:

- **ফাংশনের ভেতরে:** কোনো নির্দিষ্ট ফাংশনের একদম শুরুতে।
- **ফাইলের শুরুতে:** যদি একটি ফাইলের সব ফাংশনই সার্ভার সাইডে চালাতে চান।

---

### ৩. বাস্তব উদাহরণ (Example)

ধরা যাক, আমরা একটি ইউজার ফর্ম বানাবো যেখানে নাম ইনপুট দিলে সেটি সার্ভারে সেভ হবে (বা কনসোলে দেখাবে)।

#### ধাপ ১: সার্ভার অ্যাকশন তৈরি করা (`actions.js`)

একটি আলাদা ফাইল তৈরি করা ভালো যেখানে আমরা আমাদের সার্ভার লজিক রাখবো।

```javascript
// app/actions.js
"use server"; // এই ফাইলের সব ফাংশন সার্ভারে চলবে

export async function createUserName(formData) {
  const name = formData.get("username");

  // এখানে আপনি ডেটাবেসে ডেটা সেভ করার কোড লিখতে পারেন
  console.log(`Server received name: ${name}`);

  return { message: "সফলভাবে সেভ হয়েছে!" };
}
```

#### ধাপ ২: ক্লায়েন্ট কম্পোনেন্টে ব্যবহার করা (`UserForm.js`)

```javascript
// app/UserForm.js
"use client"; // এটি ক্লায়েন্ট কম্পোনেন্ট

import { createUserName } from "./actions";

export default function UserForm() {
  return (
    <form action={createUserName}>
      <input type="text" name="username" placeholder="আপনার নাম লিখুন" />
      <button type="submit">সেভ করুন</button>
    </form>
  );
}
```

---

### ৪. কেন এটি ব্যবহার করবেন? (সুবিধাসমূহ)

- **API Route লেখার ঝামেলা নেই:** আলাদা করে GET বা POST রিকোয়েস্ট হ্যান্ডেল করার প্রয়োজন হয় না।
- **নিরাপত্তা (Security):** এই ফাংশনের ভেতরের কোড কখনোই ব্রাউজারে যায় না, তাই এখানে API Key বা Database Credentials নিরাপদে ব্যবহার করা যায়।
- **কম্পোনেন্ট কোড পরিষ্কার থাকে:** লজিকগুলো আলাদা ফাইলে রাখা যায়।
- **Progressive Enhancement:** ফর্মগুলো জাভাস্ক্রিপ্ট লোড হওয়ার আগেই কাজ করতে পারে (যদি সঠিকভাবে কনফিগার করা হয়)।

### ৫. কিছু জরুরি নিয়ম

- **Async হতে হবে:** সার্ভার অ্যাকশন ফাংশন অবশ্যই `async` হতে হবে।
- **শুধুমাত্র সার্ভার সাইডে কাজ:** এটি ব্রাউজারে রান করে না, শুধুমাত্র সার্ভারে রান করে রেজাল্ট ক্লায়েন্টে পাঠায়।
- **Serializability:** আপনি এই ফাংশন থেকে শুধুমাত্র এমন ডেটা রিটার্ন করতে পারবেন যা JSON আকারে পাঠানো সম্ভব (যেমন: String, Object, Number)। সরাসরি কোনো জটিল ফাংশন রিটার্ন করা যাবে না।

===========

আসলে সাধারণ নিয়ম অনুযায়ী, **Server Action** সরাসরি `useEffect`-এর ভেতরে কল করার চেয়ে ডাটা ফেচিংয়ের জন্য Next.js-এর **Server Components** (async/await) ব্যবহার করা বেশি কার্যকর।

তবে, আপনি যদি চান যে কোনো ইন্টার‍্যাকশনের কারণে বা ক্লায়েন্ট সাইড থেকে `useEffect` ব্যবহার করে একটি সার্ভার অ্যাকশন কল করবেন, তবে নিচের উদাহরণটি দেখুন। এখানে একটি সার্ভার অ্যাকশন ব্যবহার করে ডাটাবেস (বা ফেক ডেটা) থেকে তথ্য আনব।

---

### ধাপ ১: সার্ভার অ্যাকশন তৈরি করা (`actions.js`)

```javascript
"use server";

// এটি একটি সার্ভার অ্যাকশন যা ডাটা ফেচ করে পাঠাবে
export async function getProductData() {
  // এখানে আপনি ডাটাবেস কুয়েরি করতে পারেন (যেমন: Prisma বা Mongoose দিয়ে)
  const product = {
    id: 1,
    name: "iPhone 15 Pro",
    price: "$999",
  };

  return product;
}
```

### ধাপ ২: ক্লায়েন্ট কম্পোনেন্টে `useEffect`-এর ভেতর ব্যবহার করা

```javascript
"use client";

import { useState, useEffect } from "react";
// সার্ভার অ্যাকশনটি ইম্পোর্ট করুন
import { getProductData } from "./actions";

export default function ProductPage() {
  const [product, setProduct] = useState(null);

  useEffect(() => {
    // একটি async ফাংশন তৈরি করে সার্ভার অ্যাকশন কল করা
    const fetchData = async () => {
      const data = await getProductData();
      setProduct(data);
    };

    fetchData();
  }, []); // কম্পোনেন্ট লোড হওয়ার পর একবার চলবে

  if (!product) return <p>লোড হচ্ছে...</p>;

  return (
    <div style={{ padding: "20px", border: "1px solid #ccc" }}>
      <h1>{product.name}</h1>
      <p>দাম: {product.price}</p>
    </div>
  );
}
```

---

### এখানে কী ঘটছে?

১. **`actions.js`**: এটি সার্ভারে চলে। যখন ব্রাউজার থেকে `getProductData` কল হয়, তখন Next.js ব্যাকএন্ডে একটি ছোট POST রিকোয়েস্ট পাঠায় এবং ডাটা নিয়ে আসে।
২. **`useEffect`**: কম্পোনেন্টটি ব্রাউজারে রেন্ডার হওয়ার সাথে সাথে সার্ভার অ্যাকশনটিকে কল করে এবং প্রাপ্ত ডাটাটি `useState`-এ সেট করে দেয়।

### একটি গুরুত্বপূর্ণ টিপস (Pro Tip):

যদি আপনার কাজ শুধু ডাটা ফেচ করে দেখানো হয়, তবে `useEffect` বা Client Component ব্যবহার না করে সরাসরি **Server Component** ব্যবহার করা ভালো। এতে কোড অনেক কমে যায়:

```javascript
// সরাসরি সার্ভার কম্পোনেন্ট (কোনো "use client" নেই)
import { getProductData } from "./actions";

export default async function ProductPage() {
  const product = await getProductData(); // সরাসরি await ব্যবহার করা যায়

  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.price}</p>
    </div>
  );
}
```

**সার্ভার অ্যাকশন** সাধারণত ডাটা **মিউটেশন** (যেমন: ফর্ম সাবমিট, ডিলিট করা) এর জন্য বেশি ব্যবহৃত হয়। তবে উপরে দেখানো নিয়মে আপনি ডাটা ফেচিংও করতে পারেন।
