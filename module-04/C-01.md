Next.js-এর **Server Components (RSC)**-এ ডেটা ফেচ করার পদ্ধতি ক্লায়েন্ট-সাইড (যেমন: `useEffect`) থেকে সম্পূর্ণ আলাদা এবং অনেক বেশি সহজ। এখানে সরাসরি `async/await` ব্যবহার করা যায়।

নিচে বিস্তারিত প্রসেসটি ধাপে ধাপে আলোচনা করা হলো:

---

### ১. `async` কম্পোনেন্ট তৈরি করা

Server Component-এ ডেটা ফেচ করার জন্য আপনাকে ফাংশনটিকে একটি `async` ফাংশন হিসেবে ঘোষণা করতে হবে। এটি শুধুমাত্র সার্ভার কম্পোনেন্টেই সম্ভব।

### ২. সরাসরি `fetch` ব্যবহার

আপনি সরাসরি কম্পোনেন্টের বডির ভেতরে `fetch` কল করতে পারেন। এর জন্য কোনো `useState` বা `useEffect`-এর প্রয়োজন নেই।

```javascript
// app/posts/page.js

async function getPosts() {
  const res = await fetch("https://api.example.com/posts");

  if (!res.ok) {
    // এটি করলে আপনার error.js ফাইলটি ট্রিগার হবে
    throw new Error("Failed to fetch data");
  }

  return res.json();
}

export default async function Page() {
  const posts = await getPosts();

  return (
    <main>
      <h1>Blog Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </main>
  );
}
```

---

### ৩. ডেটা ফেচিং-এর ধরণ (Caching & Revalidation)

Next.js `fetch` এপিআই-কে এক্সটেন্ড করেছে যাতে আপনি সার্ভারে ডেটা ক্যাশ (Cache) করতে পারেন।

- **Static Data (Force Cache):** ডিফল্টভাবে Next.js ডেটা ক্যাশ করে রাখে। এটি বিল্ড টাইমে ফেচ হয়।

```javascript
fetch("https://api.example.com/data", { cache: "force-cache" });
```

- **Dynamic Data (No Store):** প্রতিবার রিকোয়েস্টে নতুন ডেটা চাইলে:

```javascript
fetch("https://api.example.com/data", { cache: "no-store" });
```

- **Revalidating (ISR):** একটি নির্দিষ্ট সময় পর পর ডেটা আপডেট করতে চাইলে:

```javascript
fetch("https://api.example.com/data", { next: { revalidate: 3600 } }); // প্রতি ১ ঘণ্টায় আপডেট হবে
```

---

### ৪. ডেটাবেস থেকে সরাসরি ফেচিং

Server Component সরাসরি সার্ভারে চলে, তাই আপনি কোনো API রাউট ছাড়াই সরাসরি আপনার Database (Prisma, Mongoose, SQL) কল করতে পারেন।

```javascript
import { db, user } from "@/lib/db";

export default async function Page() {
  const alluser = await db.select().from(user); // সরাসরি ডাটাবেস কল

  return (
    <ul>
      {alluser.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

- এটার ব্যাখ্যা ঃ

### ১. সরাসরি ডাটাবেস কোয়েরি (Direct DB Call)

সাধারণত ফ্রন্টএন্ড থেকে ডেটা পেতে `fetch('/api/users')` করতে হয়। কিন্তু এখানে কোনো API কল ছাড়াই সরাসরি সার্ভার সাইড থেকে ডাটাবেসকে কমান্ড দেওয়া হচ্ছে: `db.select().from(user)`। এটি SQL-এর `SELECT * FROM user` কমান্ডের মতো কাজ করছে।

### ২. সার্ভার-সাইড এক্সিকিউশন (Zero Client JS)

এই পুরো কোডটি আপনার **Node.js সার্ভারে** রান হচ্ছে। ব্রাউজার শুধু তৈরি করা `<ul>` এবং `<li>` সংবলিত HTML ফাইলটি পাবে। ডাটাবেসের সিক্রেট বা কানেকশন ডিটেইলস ব্রাউজারে পৌঁছাবে না।

### ৩. টাইপ-সেফ ডেটা হ্যান্ডলিং

`alluser` ভেরিয়েবলটিতে ডাটাবেস থেকে আসা অবজেক্টগুলোর একটি অ্যারে জমা হচ্ছে। এরপর `.map()` ব্যবহার করে সেই ডেটাগুলোকে লিস্ট আকারে স্ক্রিনে দেখানো হচ্ছে।
